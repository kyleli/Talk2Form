{% load static %}
{% csrf_token %}

<!DOCTYPE html>
<html>
<head>
    <title>Form Created</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <link href="{% static 'css/styles.css' %}" rel="stylesheet">
</head>
<body>
    <div class="recording-icons">
        <div id="recording-time">0:00 / 30:00</div>
        <button id="start-btn" class="start-btn">
            <i class="ph ph-microphone"></i>
        </button>
        <button id="pause-btn" class="pause-btn" style="display: none;">
            <i class="ph ph-pause"></i>
        </button>
        <button id="resume-btn" class="resume-btn" style="display: none;">
            <i class="ph ph-play"></i>
        </button>
        <button id="stop-btn" class="stop-btn" style="display: none;">
            <i class="ph ph-stop"></i>
        </button>
    </div>
    <div id="recording-time"></div>
    <script>
        const csrfToken = document.querySelector('input[name="csrfmiddlewaretoken"]').value;

        const formId = '{{ form.id }}';
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const recordingTimeElement = document.getElementById('recording-time');

        let mediaRecorder; // MediaRecorder object
        let startTime;
        let intervalId;
        let elapsedTime = 0;

        startBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        pauseBtn.addEventListener('click', pauseRecording);
        resumeBtn.addEventListener('click', resumeRecording);

        function startRecording() {
            startBtn.style.display = 'none'; // Hide the start button
            pauseBtn.style.display = 'inline-block'; // Show the pause button
            stopBtn.style.display = 'inline-block';

            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    let mimeType = 'audio/webm;codec=opus';
                    let dataType = 'webm';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/mp4;codec=aac';
                        dataType = 'mp4';
                    }
                    mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
                    mediaRecorder.addEventListener('dataavailable', function(e) {
                        if (e.data.size > 0) {
                            sendAudioChunk(e.data, dataType); // Send the chunk to the server
                        }
                    });
                    mediaRecorder.start();
                    startTime = new Date().getTime();
                    intervalId = setInterval(updateRecordingTime, 1000);
                    setTimeout(stopRecording, 1800000)
                })
                .catch(function(err) {
                    console.error('Error accessing microphone:', err);
                });
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(function(track) {
                    track.stop();
                });
                clearInterval(intervalId);
            }
        }

        function pauseRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.pause();
                clearInterval(intervalId); // Pause the timer
                elapsedTime = new Date().getTime() - startTime;
                pauseBtn.style.display = 'none'; // Hide the pause button
                resumeBtn.style.display = 'inline-block'; // Show the resume button
            }
        }

        function resumeRecording() {
            if (mediaRecorder && mediaRecorder.state === 'paused') {
                mediaRecorder.resume();
                startTime = new Date().getTime() - elapsedTime; // Update the start time
                intervalId = setInterval(updateRecordingTime, 1000); // Resume the timer
                resumeBtn.style.display = 'none'; // Hide the resume button
                pauseBtn.style.display = 'inline-block'; // Show the pause button
            }
        }

        function sendAudioChunk(chunk, dataType) {
            const formData = new FormData();
            formData.append('audioChunk', chunk);
            formData.append('form_id', formId);
            formData.append('dataType', dataType);
            formData.append('csrfmiddlewaretoken', csrfToken);

            fetch(`/stop_audio/${formId}/`, {
                method: 'POST',
                body: formData
            })
            .then(function(response) {
                response.json().then(function(json){console.log(json)});
                window.location.href = `/response_form/${formId}/`;
                chunk = null;
            })
            .catch(function(error) {
                console.error('Error sending audio chunk:', error);
            });
        }

        function updateRecordingTime() {
            const currentTime = new Date().getTime();
            const elapsedTime = currentTime - startTime;
            const maxRecordingTime = 1800000; // 30 minutes in milliseconds
            const remainingTime = Math.max(maxRecordingTime - elapsedTime, 0);
            const currentMinutes = Math.floor(elapsedTime / 60000);
            const currentSeconds = Math.floor((elapsedTime % 60000) / 1000);
            const maxMinutes = Math.floor(maxRecordingTime / 60000);
            const maxSeconds = Math.floor((maxRecordingTime % 60000) / 1000);
            recordingTimeElement.textContent = `${currentMinutes}:${currentSeconds.toString().padStart(2, '0')} / ${maxMinutes}:${maxSeconds.toString().padStart(2, '0')}`;
        }
    </script>
</body>
</html>
