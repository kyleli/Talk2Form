{% load static %}
{% csrf_token %}

<!DOCTYPE html>
<html>
<head>
    <title>Form Created</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <link href="{% static 'css/styles.css' %}" rel="stylesheet">
</head>
<body>
    <h1>Form Created Successfully</h1>
    <p>Form ID: {{ form }}</p>
    <p>Template: {{ form.template }}</p>
    {% for response in responses %}
    <p>{{ response.question.question }}</p>
    <p>{{ response.response }}</p>
    {% endfor %}
    <div class="bottom-icons">
        <button id="start-btn">Start Recording</button>
        <button id="stop-btn">Stop Recording</button>
        <button id="pause-btn">Pause Recording</button>
        <button id="resume-btn">Resume Recording</button>
    </div>
    <div id="recording-time"></div>
    <script>
        const csrfToken = document.querySelector('input[name="csrfmiddlewaretoken"]').value;

        const formId = '{{ form.id }}';
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const recordingTimeElement = document.getElementById('recording-time');

        let mediaRecorder; // MediaRecorder object
        let startTime;
        let intervalId;
        let elapsedTime = 0;

        startBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        pauseBtn.addEventListener('click', pauseRecording);
        resumeBtn.addEventListener('click', resumeRecording);

        function startRecording() {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    let mimeType = 'audio/webm;codec=opus';
                    let dataType = 'webm';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/mp4;codec=aac';
                        dataType = 'mp4';
                    }
                    mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
                    mediaRecorder.addEventListener('dataavailable', function(e) {
                        if (e.data.size > 0) {
                            sendAudioChunk(e.data, dataType); // Send the chunk to the server
                        }
                    });
                    mediaRecorder.start();
                    startTime = new Date().getTime();
                    intervalId = setInterval(updateRecordingTime, 1000);
                    setTimeout(stopRecording, 1800000)
                })
                .catch(function(err) {
                    console.error('Error accessing microphone:', err);
                });
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(function(track) {
                    track.stop();
                });
                clearInterval(intervalId);
            }
        }

        function pauseRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.pause();
                clearInterval(intervalId); // Pause the timer
                elapsedTime = new Date().getTime() - startTime;
            }
        }

        function resumeRecording() {
            if (mediaRecorder && mediaRecorder.state === 'paused') {
                mediaRecorder.resume();
                startTime = new Date().getTime() - elapsedTime; // Update the start time
                intervalId = setInterval(updateRecordingTime, 1000); // Resume the timer
            }
        }

        function sendAudioChunk(chunk, dataType) {
            const formData = new FormData();
            formData.append('audioChunk', chunk);
            formData.append('form_id', formId);
            formData.append('dataType', dataType);
            formData.append('csrfmiddlewaretoken', csrfToken);

            fetch(`/stop_audio/${formId}/`, {
                method: 'POST',
                body: formData
            })
            .then(function(response) {
                response.json().then(function(json){console.log(json)});
                window.location.href = `/response_form/${formId}/`;
                chunk = null;
            })
            .catch(function(error) {
                console.error('Error sending audio chunk:', error);
            });
        }

        function updateRecordingTime() {
            const currentTime = new Date().getTime();
            const elapsedTime = currentTime - startTime;
            const maxRecordingTime = 1800000; // 30 minutes in milliseconds
            const remainingTime = Math.max(maxRecordingTime - elapsedTime, 0);
            const currentMinutes = Math.floor(elapsedTime / 60000);
            const currentSeconds = Math.floor((elapsedTime % 60000) / 1000);
            const maxMinutes = Math.floor(maxRecordingTime / 60000);
            const maxSeconds = Math.floor((maxRecordingTime % 60000) / 1000);
            recordingTimeElement.textContent = `Recording Time: ${currentMinutes}:${currentSeconds.toString().padStart(2, '0')} / ${maxMinutes}:${maxSeconds.toString().padStart(2, '0')}`;
        }
    </script>
</body>
</html>